import fs from "fs";
import { subtask, task } from "hardhat/config";
import path from "path";

import {
  TASK_GAS_REPORTER_MERGE,
  TASK_GAS_REPORTER_MERGE_REPORTS,
} from "../constants";
import { GasReporterOutput } from "../types";

/**
 * Task for merging multiple gasReporterOutput.json files generated by eth-gas-reporter
 * This task is necessary when we want to generate different parts of the reports
 * parallelized on different jobs, then merge the results and upload it to a CI service.
 */

subtask(TASK_GAS_REPORTER_MERGE_REPORTS)
  .addOptionalVariadicPositionalParam(
    "inputFiles",
    "Path of several gasReporterOutput.json files to merge",
    []
  )
  .setAction(async ({ inputFiles }: { inputFiles: string[] }) => {
    const reports = inputFiles.map((input) =>
      JSON.parse(fs.readFileSync(input, "utf-8"))
    );
    return mergeReports(reports);
  });

task(TASK_GAS_REPORTER_MERGE)
  .addOptionalParam(
    "output",
    "Target file to save the merged report",
    "gasReporterOutput.json"
  )
  .addVariadicPositionalParam(
    "input",
    "A list of gasReporterOutput.json files generated by eth-gas-reporter. Files can be defined using glob patterns"
  )
  .setAction(async (taskArguments, { run }) => {
    const output = path.resolve(process.cwd(), taskArguments.output);

    // Parse input files and calculate glob patterns
    // TODO: glob is deprecated at HH
    const { globSync } = await import("hardhat/internal/util/glob");
    const arrayUniq = require("array-uniq");
    const inputFiles = arrayUniq(taskArguments.input.map(globSync).flat()).map(
      (inputFile: string) => path.resolve(inputFile)
    );

    if (inputFiles.length === 0) {
      throw new Error(
        `No files found for the given input: ${taskArguments.input.join(" ")}`
      );
    }

    console.log(`Merging ${inputFiles.length} input files:`);
    inputFiles.forEach((inputFile: string) => {
      console.log("  - ", inputFile);
    });

    console.log("\nOutput: ", output);

    const result = await run(TASK_GAS_REPORTER_MERGE_REPORTS, { inputFiles });

    fs.writeFileSync(output, JSON.stringify(result), "utf-8");
  });

/**
 * Try to merge several gas reporter output objects into one. It will also
 * validate that the options are the same to make sure that the reports were
 * generated by the same source.
 */
export function mergeReports(
  reports: GasReporterOutput[]
): GasReporterOutput {
  const result: any = {
    namespace: null,
    options: null,
    data: {
      methods: {},
      deployments: [],
      blockLimit: null,
    },
  };

  for (const report of reports) {
    if (result.options === null) {
      result.options = report.options;
    }

    if (result.namespace === null) {
      result.namespace = report.namespace;
    }

    if (result.namespace !== report.namespace) {
      throw new Error("Cannot merge reports with different namespaces");
    }

    // Update options.gasPrice only if the newer one has a bigger number
    if (typeof report.options.gasPrice === "number") {
      if (
        typeof result.options.gasPrice !== "number" ||
        result.options.gasPrice < report.options.gasPrice
      ) {
        result.options.gasPrice = report.options.gasPrice;
      }
    } else {
      result.options.gasPrice = report.options.gasPrice;
    }

    if (report.data === undefined || typeof report.options.blockLimit !== "number") {
      throw new Error(`Invalid "data" property for given report`);
    }

    if (result.data.blockLimit === null) {
      result.data.blockLimit = report.options.blockLimit;
    } else if (result.data.blockLimit !== report.options.blockLimit) {
      throw new Error('"data.blockLimit" should be the same on all reports');
    }

    if (report.data.methods === undefined) {
      throw new Error(`Missing "data.methods" property on given report`);
    }

    // Merge data.methods objects
    Object.entries(report.data.methods).forEach(([key, value]) => {
      if (result.data.methods[key] === undefined) {
        result.data.methods[key] = value;
        return;
      }

      result.data.methods[key].gasData = [
        ...result.data!.methods[key].gasData,
        ...report.data!.methods[key].gasData,
      ].sort((a, b) => a - b);

      result.data.methods[key].numberOfCalls +=
        report.data!.methods[key].numberOfCalls;
    });

    if (!Array.isArray(report.data.deployments)) {
      throw new Error(`Invalid "data.deployments" property on given report`);
    }

    // Merge data.deployments objects
    report.data.deployments.forEach((deployment) => {
      const current = result.data.deployments.find(
        (d: any) => d.name === deployment.name
      );

      if (current !== undefined) {
        current.gasData = [...current.gasData, ...deployment.gasData].sort(
          (a, b) => a - b
        );
      } else {
        result.data.deployments.push(deployment);
      }
    });
  }

  return result;
}
